\chapter{Exercise 6 : Defining }

To manipulate numbers, lists, vectors and other data we've seen 
we want to be able to refer to them. Much of programming is just that:
we name data structures and manipulate them.

This is how to name, or in the Clojure parlance define, an element:
\clojure{ (def one 1) }. "one" now refers to the number "1". In Clojure code
"one" evaluates to the number "1".

To talk about "one", the entity referring to the number "1", Clojure folks have
come up with the name "symbol" because it is quite cumbersome to say "the entity referring to..." all the time. "one" is a symbol. \clojure{def} creates symbols.

For this exercise we will use the repl. Start it up and type the following on each line. No need to type the comments though!

\begin{code}{ex6.clj}
<< d['code/ex6.clj|pyg|l'] >>
\end{code} 

What you should see:
\begin{code}{Terminal Output}
\begin{Verbatim}
<< d['code/ex6.clj|cljint'] >>
\end{Verbatim}
\end{code}

That last line might surprise you. This is one of the key aspect of Lisp languages. Listen closely: everything is constant (or final if you know Java).

You would have to redefine the result to get a symbol evaluating to it.

The reasons for this will be explained later. One of them is concurrency.

I should also make something clear to you now. The "everything is constant" business is not {\em entirely} true in Clojure. For what we will be doing and
for most actual real-life situations, the saying holds (or at least you should make it hold by not using weird mutable things). 

\begin{aside}{Naming Convention}
Notice how hyphens (-) instead of underscores (\_) or camelcase (e.g. camelCase) are used when naming a symbol with multiple words. This is the naming convention in Clojure. Whenever you would use a space in normal writing use a hyphen for the symbol's name.
\end{aside}
